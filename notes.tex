\documentclass{notes}
\usetikzlibrary{shapes, shapes.geometric}

\class{CS 181 (Introduction to Formal Languages and Automata Theory)}

\begin{document}

\section{Deterministic finite automata (DFAs)}

\subsection{Basic notions}

\begin{defn}
  An \textbf{alphabet} is any finite set of symbols.
\end{defn}

\begin{eg}
  Binary alphabet: $\left \{ \verb~0~, \verb~1~ \right \}$
\end{eg}

\begin{eg}
  English alphabet: $\left \{ \verb~a~, \verb~b~, \dots, \verb~c~ \right \}$
\end{eg}

\begin{defn}
  A \textbf{string} is any finite sequence of symbols from a given alphabet.
\end{defn}

\begin{eg}
  \verb~001010110101~
\end{eg}

\begin{eg}
  \verb~abracadabra~
\end{eg}

\begin{eg}
  $\varepsilon$ (empty string)
\end{eg}

\begin{defn}
  A \textbf{language} is a set of strings over a given alphabet.
\end{defn}

\begin{eg}
  $\varnothing$ (empty language)
\end{eg}

\begin{eg}
  $\left \{ \varepsilon \right \}$
\end{eg}

\begin{eg}
  $\left \{ \verb~acclaim~, \verb~aim~, \verb~brim~, \dots \right \}$
\end{eg}

\begin{eg}
  $\left \{ \verb~0~, \verb~1~, \verb~00~, \verb~11~, \dots \right \}$
\end{eg}

\begin{defn}
  A \textbf{computational device} is a mechanism that inputs a string and either accepts or rejects it.
\end{defn}

\subsection{Deterministic finite automata}

\begin{itemize}
  \item Choose an alphabet: $\left \{ \verb~a~, \verb~b~ \right \}$.
  \item Draw states.
  \item Choose start state and accept states.
  \item Draw transitions (out of every state on every symbol).
\end{itemize}

\begin{minipage}{0.5 \textwidth}
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[below left = of q1, accepting, state, minimum size = 2em] (q2) {};
      \node[below right = of q1, accepting, state, minimum size = 2em] (q3) {};
      \node[below right = of q2, state, minimum size = 2em] (q4) {};
      \draw[->]
      (q1) edge[above left] node{\verb~a~} (q2)
      (q1) edge[above right] node{\verb~b~} (q3)
      (q2) edge[loop left] node{\verb~a~} (q2)
      (q2) edge[below left] node{\verb~b~} (q4)
      (q3) edge[below right] node{\verb~a~} (q4)
      (q3) edge[loop right] node{\verb~b~} (q3)
      (q4) edge[loop below] node{\verb~a~,\verb~b~} (q4)
      ;
    \end{tikzpicture}
  \end{center}
\end{minipage}%
\begin{minipage}{0.5 \textwidth}
  \begin{center}
    \begin{tabular}{cc}
      Input & Output \\ 
      \hline
      $\varepsilon$ & reject \\ 
      \verb~ab~ & reject \\ 
      \verb~aaa~ & accept \\ 
      \verb~bb~ & accept
    \end{tabular}
  \end{center}
\end{minipage}

In words, this machine accepts nonempty strings of all \verb~a~'s or all \verb~b~'s.

\begin{defn}
  The \textbf{language} of a DFA is the set of all strings it accepts.
\end{defn}

\begin{eg}
  
  \begin{minipage}{0.5 \textwidth}
    \begin{center}
      \begin{tikzpicture}[> = stealth, node distance = 3em]
        \node[accepting, initial, initial text=, state, minimum size = 2em] (q1) at (90 : 1.5) {};
        \node[state, minimum size = 2em] (q2) at (330 : 1.5) {};
        \node[state, minimum size = 2em] (q3) at (210 : 1.5) {};
        \draw[->]
        (q1) edge[loop above] node{\verb~0~} (q1)
        (q1) edge[below left] node{\verb~1~} (q2)
        (q1) edge[bend right, above left] node{\verb~2~} (q3)
        (q2) edge[loop right] node{\verb~0~} (q2)
        (q2) edge[above] node{\verb~1~} (q3)
        (q2) edge[bend right, above right] node{\verb~2~} (q1)
        (q3) edge[loop left] node{\verb~0~} (q3)
        (q3) edge[below right] node{\verb~1~} (q1)
        (q3) edge[bend right, below] node{\verb~2~} (q2)
        ;
      \end{tikzpicture}
    \end{center}
  \end{minipage}%
  \begin{minipage}{0.5 \textwidth}
    \begin{center}
      \begin{tabular}{cc}
        Input & Output \\ 
        \hline
        \verb~00...0~ & accept \\ 
        \verb~12~ & accept \\ 
        \verb~111~ & accept \\ 
        \verb~20~ & reject \\ 
        \verb~1~ & reject
      \end{tabular}
    \end{center}
  \end{minipage}

  \begin{center}
    Alphabet: $\left \{ \verb~0~, \verb~1~, \verb~2~ \right \}$, language: $\left \{ w : 3 \mid \sum w_i \right \}$
  \end{center}
\end{eg}

\begin{eg}
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[accepting, initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[right = of q1, state, minimum size = 2em] (q2) {};
      \draw[->]
      (q1) edge[bend right, below] node{\verb~0~,\verb~1~} (q2)
      (q2) edge[bend right, above] node{\verb~0~,\verb~1~} (q1)
      ;
    \end{tikzpicture}

    Alphabet: $\left \{ \verb~0~, \verb~1~ \right \}$, language: $\left \{ w : 2 \mid \left | w \right | \right \}$
  \end{center}
\end{eg}

\begin{eg}
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[accepting, below left = of q1, state, minimum size = 2em] (q2) {};
      \node[below = of q2, state, minimum size = 2em] (q3) {};
      \node[accepting, below right = of q1, state, minimum size = 2em] (q4) {};
      \node[below = of q4, state, minimum size = 2em] (q5) {};
      \draw[->]
      (q1) edge[above left] node{\verb~a~} (q2)
      (q1) edge[above right] node{\verb~b~} (q4)
      (q2) edge[loop left] node{\verb~a~} (q2)
      (q2) edge[bend right, left] node{\verb~b~} (q3)
      (q3) edge[bend right, right] node{\verb~a~} (q2)
      (q3) edge[loop below] node{\verb~b~} (q3)
      (q4) edge[bend right, left] node{\verb~a~} (q5)
      (q4) edge[loop right] node{\verb~b~} (q4)
      (q5) edge[loop below] node{\verb~a~} (q5)
      (q5) edge[bend right, right] node{\verb~b~} (q4)
      ;
    \end{tikzpicture}

    Alphabet: $\left \{ \verb~a~, \verb~b~ \right \}$, language: $\left \{ w : w \neq \varepsilon \land w_1 = w_{\left | w \right |  } \right \}$
  \end{center}
\end{eg}

\subsection{Designing DFAs}

We will be using the binary alphabet $\left \{ \verb~0~, \verb~1~ \right \}$.

\begin{eg}
  Language: $\varnothing$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {};
      \draw[->]
      (q1) edge[loop right] node{\verb~0~,\verb~1~} (q1)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\begin{eg}
  Language: $\left \{ w : \text{every odd position is a \verb~1~} \right \}$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[accepting, initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[accepting, below right = of q1, state, minimum size = 2em] (q2) {};
      \node[above right = of q1, state, minimum size = 2em] (q3) {};
      \draw[->]
      (q1) edge[above left] node{\verb~0~} (q3)
      (q1) edge[bend right, below left] node{\verb~1~} (q2)
      (q2) edge[bend right, above right] node{\verb~0~,\verb~1~} (q1)
      (q3) edge[loop right] node{\verb~0~,\verb~1~} (q3)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\begin{eg}
  Language: $\left \{ w : \text{$w$ ends in \verb~0~} \right \}$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[right = of q1, accepting, state, minimum size = 2em] (q2) {};
      \draw[->]
      (q1) edge[bend right, below] node{\verb~0~} (q2)
      (q1) edge[loop above] node{\verb~1~} (q1)
      (q2) edge[loop below] node{\verb~0~} (q2)
      (q2) edge[bend right, above] node{\verb~1~} (q1)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\begin{eg}
  Language: $\left \{ w : \text{$w$ begins with \verb~1~, ends with \verb~0~} \right \}$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[above right = of q1, state, minimum size = 2em] (q2) {};
      \node[right = of q2, accepting, state, minimum size = 2em] (q3) {};
      \node[below right = of q1, state, minimum size = 2em] (q4) {};
      \draw[->]
      (q1) edge[below left] node{\verb~0~} (q4)
      (q1) edge[above left] node{\verb~1~} (q2)
      (q2) edge[bend right, below] node{\verb~0~} (q3)
      (q2) edge[loop above] node{\verb~1~} (q2)
      (q3) edge[loop right] node{\verb~0~} (q3)
      (q3) edge[bend right, above] node{\verb~1~} (q2)
      (q4) edge[loop right] node{\verb~0~,\verb~1~} (q4)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\begin{eg}
  Language: $\left \{ w : \left | w \right | \leq 4  \right \}$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[accepting, initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[right = of q1, accepting, state, minimum size = 2em] (q2) {};
      \node[accepting, right = of q2, state, minimum size = 2em] (q3) {};
      \node[accepting, right = of q3, state, minimum size = 2em] (q4) {};
      \node[accepting, right = of q4, state, minimum size = 2em] (q5) {};
      \node[right = of q5, state, minimum size = 2em] (q6) {};
      \draw[->]
      (q1) edge[above] node{\verb~0~,\verb~1~} (q2)
      (q2) edge[above] node{\verb~0~,\verb~1~} (q3)
      (q3) edge[above] node{\verb~0~,\verb~1~} (q4)
      (q4) edge[above] node{\verb~0~,\verb~1~} (q5)
      (q5) edge[above] node{\verb~0~,\verb~1~} (q6)
      (q6) edge[loop right] node{\verb~0~,\verb~1~} (q6)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\newpage

\begin{eg}
  Language: $\left \{ w : 1000 \mid \left | w \right | \right \}$
  
  In words, each state represents a remainder modulo 1000, and only the 0 state is accepting.
\end{eg}

\begin{eg}
  Language: $\left \{ w : \text{$w$ contains \verb~0101~ as a substring} \right \}$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {$\varepsilon$};
      \node[right = of q1, state, minimum size = 2em] (q2) {\verb~0~};
      \node[right = of q2, state, minimum size = 2em] (q3) {\verb~01~};
      \node[right = of q3, state, minimum size = 2em] (q4) {\verb~010~};
      \node[accepting, right = of q4, state, minimum size = 2em] (q5) {\verb~0101~};
      \draw[->]
      (q1) edge[above] node{\verb~0~} (q2)
      (q1) edge[loop above] node{\verb~1~} (q1)
      (q2) edge[loop above] node{\verb~0~} (q2)
      (q2) edge[above] node{\verb~1~} (q3)
      (q3) edge[above] node{\verb~0~} (q4)
      (q3) edge[bend right = 75, above] node{\verb~1~} (q1)
      (q4) edge[bend right = 60, above] node{\verb~0~} (q2)
      (q4) edge[above] node{\verb~1~} (q5)
      (q5) edge[loop right] node{\verb~0~,\verb~1~} (q5)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\begin{eg}[Week 1 Discussion]
  $L = \left \{ w : \left | w \right | > 0 \land \text{$w$ contains only \verb~1~s} \right \}$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[right = of q1, accepting, state, minimum size = 2em] (q2) {};
      \node[right = of q2, state, minimum size = 2em] (q3) {};
      \draw[->]
      (q1) edge[bend right, below] node{\verb~0~} (q3)
      (q1) edge[above] node{\verb~1~} (q2)
      (q2) edge[above] node{\verb~0~} (q3)
      (q2) edge[loop above] node{\verb~1~} (q2)
      (q3) edge[loop right] node{\verb~0~,\verb~1~} (q3)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\begin{eg}[Week 1 Discussion]
  $L = \left \{ w : \text{$w$ ends in \verb~1101~} \right \}$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[right = of q1, state, minimum size = 2em] (q2) {};
      \node[right = of q2, state, minimum size = 2em] (q3) {};
      \node[right = of q3, state, minimum size = 2em] (q4) {};
      \node[accepting, right = of q4, state, minimum size = 2em] (q5) {};
      \draw[->]
      (q1) edge[loop below] node{\verb~0~} (q1)
      (q1) edge[bend right, below] node{\verb~1~} (q2)
      (q2) edge[bend right, above] node{\verb~0~} (q1)
      (q2) edge[above] node{\verb~1~} (q3)
      (q3) edge[above] node{\verb~0~} (q4)
      (q3) edge[loop above] node{\verb~1~} (q3)
      (q4) edge[bend right = 60, above] node{\verb~0~} (q1)
      (q4) edge[above] node{\verb~1~} (q5)
      (q5) edge[bend right = 75, above] node{\verb~0~} (q1)
      (q5) edge[bend right, above] node{\verb~1~} (q3)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\begin{eg}[Week 1 Discussion]
  $L = \left \{ w : \text{$w$ contains \verb~1101~} \right \}$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[right = of q1, state, minimum size = 2em] (q2) {};
      \node[right = of q2, state, minimum size = 2em] (q3) {};
      \node[right = of q3, state, minimum size = 2em] (q4) {};
      \node[accepting, right = of q4, state, minimum size = 2em] (q5) {};
      \draw[->]
      (q1) edge[loop below] node{\verb~0~} (q1)
      (q1) edge[bend right, below] node{\verb~1~} (q2)
      (q2) edge[bend right, above] node{\verb~0~} (q1)
      (q2) edge[above] node{\verb~1~} (q3)
      (q3) edge[above] node{\verb~0~} (q4)
      (q3) edge[loop above] node{\verb~1~} (q3)
      (q4) edge[bend right = 60, above] node{\verb~0~} (q1)
      (q4) edge[above] node{\verb~1~} (q5)
      (q5) edge[loop right] node{\verb~0~,\verb~1~} (q5)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\newpage

\subsection{Formal definitions}

\begin{defn}
  A DFA is a tuple $(Q, \Sigma, \delta, q_{0}, F)$
  where
  \begin{itemize}
    \item $Q =$ set of states, 
    \item $\Sigma =$ alphabet, 
    \item $\delta =$ transition function ($\delta \colon Q \times \Sigma \to Q$), 
    \item $q_0 =$ start state ($q_0 \in Q$), and 
    \item $F =$ set of accept states ("favorable"? states, $F \subseteq Q$).
  \end{itemize}
\end{defn}

\begin{eg}
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {$A$};
      \node[accepting, right = of q1, accepting, state, minimum size = 2em] (q2) {$B$};
      \node[right = of q2, state, minimum size = 2em] (q3) {$C$};
      \draw[->]
      (q1) edge[loop above] node{\verb~0~} (q1)
      (q1) edge[above] node{\verb~1~} (q2)
      (q2) edge[bend right, below] node{\verb~0~} (q3)
      (q2) edge[loop above] node{\verb~1~} (q2)
      (q3) edge[bend right, above] node{\verb~0~,\verb~1~} (q2)
      ;
    \end{tikzpicture}
  \end{center}
  
  Formal description: $(\left \{ A, B, C \right \}, \left \{ \verb~0~, \verb~1~ \right \}, \delta, A, \left \{ B \right \})$ where $\delta$ is defined by the table
  \begin{center}
    \begin{tabular}{c|cc}
      & \verb~0~ & \verb~1~ \\ 
      \hline
      $A$ & $A$ & $B$ \\ 
      $B$ & $C$ & $B$ \\ 
      $C$ & $B$ & $B$.
    \end{tabular}
  \end{center}
\end{eg}

\begin{eg}
  Formal description: $(\left \{ A, B, C, D, E \right \}, \left \{ \verb~0~, \verb~1~ \right \}, \delta, C, \left \{ C \right \})$ where $\delta$ is defined by the table 
  \begin{center}
    \begin{tabular}{c|cc}
      & \verb~0~ & \verb~1~ \\ 
      \hline
      $A$ & $A$ & $B$ \\ 
      $B$ & $A$ & $C$ \\ 
      $C$ & $B$ & $D$ \\ 
      $D$ & $C$ & $E$ \\ 
      $E$ & $D$ & $E$.
    \end{tabular}
  \end{center}
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[state, minimum size = 2em] (q1) {$A$};
      \node[right = of q1, state, minimum size = 2em] (q2) {$B$};
      \node[accepting, initial above, initial text=, right = of q2, state, minimum size = 2em] (q3) {$C$};
      \node[right = of q3, state, minimum size = 2em] (q4) {$D$};
      \node[right = of q4, state, minimum size = 2em] (q5) {$E$};
      \draw[->]
      (q1) edge[loop left] node{\verb~0~} (q1)
      (q1) edge[bend right, below] node{\verb~1~} (q2)
      (q2) edge[bend right, above] node{\verb~0~} (q1)
      (q2) edge[bend right, below] node{\verb~1~} (q3)
      (q3) edge[bend right, above] node{\verb~0~} (q2)
      (q3) edge[bend right, below] node{\verb~1~} (q4)
      (q4) edge[bend right, above] node{\verb~0~} (q3)
      (q4) edge[bend right, below] node{\verb~1~} (q5)
      (q5) edge[bend right, above] node{\verb~0~} (q4)
      (q5) edge[loop right] node{\verb~1~} (q5)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\begin{eg}
  Formal description for Example~\ref{eg:1.3.6}: $(\left \{ 0, 1, 2, \dots, 999 \right \}, \left \{ \verb~0~, \verb~1~ \right \}, \delta, 0, \left \{ 0 \right \})$ where $\delta(q, \sigma) = (q + 1) \mod 1000$.
\end{eg}

\newpage

\begin{defn}
  DFA $(Q, \Sigma, \delta, q_{0}, F)$ {\boldmath \bfseries accepts} a string $w = w_1 w_2 \dots w_n$ iff
  \[
    \delta(\cdots \delta(\delta(q_0, w_1), w_2) \cdots, w_n) \in F.
  \]
\end{defn}

\begin{defn}
  DFA $D$ {\boldmath \bfseries recognizes} the language $\mathcal L$ iff 
  \[
    \mathcal L = \left \{ w : \text{$D$ accepts $w$} \right \}.
  \]
\end{defn}

\begin{note}
  \begin{itemize}
    \item Every DFA recognizes exactly 1 language.

    \item A language has either 0 or $\infty$ DFAs recognizing it.
  \end{itemize}
\end{note}

\section{Nondeterminism}

\subsection{Basic notions}

\begin{eg}
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {$A$};
      \node[right = of q1, state, minimum size = 2em] (q2) {$B$};
      \node[right = of q2, state, minimum size = 2em] (q3) {$C$};
      \node[accepting, right = of q3, state, minimum size = 2em] (q4) {$D$};
      \draw[->]
      (q1) edge[loop above] node{\verb~0~,\verb~1~} (q1)
      (q1) edge[above] node{\verb~1~} (q2)
      (q2) edge[above] node{\verb~0~,$\varepsilon$} (q3)
      (q3) edge[above] node{\verb~1~} (q4)
      (q4) edge[loop above] node{\verb~0~,\verb~1~} (q4)
      ;
    \end{tikzpicture}
  \end{center}

  \begin{itemize}
    \item Choose an alphabet: $\left \{ \verb~0~, \verb~1~ \right \}$.

    \item Draw states.
      
    \item Choose start state and accept states.
    The steps so far are the same as those of a DFA.
      
    \item Draw transitions.
    A state may have any number of transitions on a given symbol.
    A state may also have transitions on $\varepsilon$.
  \end{itemize}
\end{eg}

\begin{defn}
  An NFA {\boldmath \bfseries accepts} $w$ iff there is \textit{at least} one path to an accept state.
\end{defn}

\newpage

\begin{eg}
  Output table for Example~\ref{eg:2.1.1}:
  \begin{center}
    \begin{tabular}{ccc}
      Input & Accepting path & Output \\ 
      \hline
      $\varepsilon$ & - & reject \\ 
      \verb~0~ & - & reject \\ 
      \verb~1~ & - & reject \\ 
      \verb~010110~ & $AABCDDD$ & accept \\
      \verb~010~ & - & reject \\ 
      \verb~11~ & $ABCD$ & accept 
    \end{tabular}
  \end{center}
  
  \begin{center}
    Language: all strings containing \verb~101~ or \verb~11~
  \end{center}
\end{eg}

\subsection{Using shortcuts}

\begin{eg}
  Language: $\varnothing$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {};
      \draw[->]
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\begin{eg}
  Language: $\left \{ \varepsilon \right \}$

  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[accepting, initial, initial text=, state, minimum size = 2em] (q1) {};
      \draw[->]
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\begin{eg}
  Language: $\left \{ w : \text{$w$ doesn't contain \verb~1~} \right \}$

  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[accepting, initial, initial text=, state, minimum size = 2em] (q1) {};
      \draw[->]
      (q1) edge[loop right] node{\verb~0~} (q1)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\begin{eg}
  Language: $\left \{ w : \text{$\left | w \right | \geq 2$ and $w$ starts and ends with \verb~0~} \right \}$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[right = of q1, state, minimum size = 2em] (q2) {};
      \node[accepting, right = of q2, state, minimum size = 2em] (q3) {};
      \draw[->]
      (q1) edge[above] node{\verb~0~} (q2)
      (q2) edge[above] node{\verb~0~} (q3)
      (q2) edge[loop above] node{\verb~0~,\verb~1~} (q2)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\subsection{Pattern matching}

\begin{eg}
  Language: $\left \{ w : \text{conatins \verb~0101~} \right \}$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[right = of q1, state, minimum size = 2em] (q2) {};
      \node[right = of q2, state, minimum size = 2em] (q3) {};
      \node[right = of q3, state, minimum size = 2em] (q4) {};
      \node[accepting, right = of q4, state, minimum size = 2em] (q5) {};
      \draw[->]
      (q1) edge[loop above] node{\verb~0~,\verb~1~} (q1)
      (q1) edge[above] node{\verb~0~} (q2)
      (q2) edge[above] node{\verb~1~} (q3)
      (q3) edge[above] node{\verb~0~} (q4)
      (q4) edge[above] node{\verb~1~} (q5)
      (q5) edge[loop above] node{\verb~0~,\verb~1~} (q5)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\newpage

\begin{eg}
  Language: $\{ w : w = \underbrace{\verb~00...0~}_{\geq 0}\underbrace{\verb~11...1~}_{\geq 0}\underbrace{\verb~00...0~}_{\geq 1} \}$ % >= 0, >= 0, >= 1
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[right = of q1, state, minimum size = 2em] (q2) {};
      \node[accepting, right = of q2, state, minimum size = 2em] (q3) {};
      \draw[->]
      (q1) edge[loop above] node{\verb~0~} (q1)
      (q1) edge[above] node{$\varepsilon$} (q2)
      (q2) edge[loop above] node{\verb~1~} (q2)
      (q2) edge[above] node{\verb~0~} (q3)
      (q3) edge[loop above] node{\verb~0~} (q3)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\begin{eg}
  Language: $\left \{ w : \text{$w$ has a \verb~1~ in the 3rd position from the end} \right \}$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[right = of q1, state, minimum size = 2em] (q2) {};
      \node[right = of q2, state, minimum size = 2em] (q3) {};
      \node[accepting, right = of q3, state, minimum size = 2em] (q4) {};
      \draw[->]
      (q1) edge[loop above] node{\verb~0~,\verb~1~} (q1)
      (q1) edge[above] node{\verb~1~} (q2)
      (q2) edge[above] node{\verb~0~,\verb~1~} (q3)
      (q3) edge[above] node{\verb~0~,\verb~1~} (q4)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\begin{eg}[Week 1 Discussion]
  $L = \left \{ w : \text{$w$ contains \verb~1101~} \right \}$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[right = of q1, state, minimum size = 2em] (q2) {};
      \node[right = of q2, state, minimum size = 2em] (q3) {};
      \node[right = of q3, state, minimum size = 2em] (q4) {};
      \node[accepting, right = of q4, state, minimum size = 2em] (q5) {};
      \draw[->]
      (q1) edge[loop above] node{\verb~0~,\verb~1~} (q1)
      (q1) edge[above] node{\verb~1~} (q2)
      (q2) edge[above] node{\verb~1~} (q3)
      (q3) edge[above] node{\verb~0~} (q4)
      (q4) edge[above] node{\verb~1~} (q5)
      (q5) edge[loop above] node{\verb~0~,\verb~1~} (q5)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\begin{eg}[Week 1 Discussion]
  $L = \{ w : w = \underbrace{\verb~11...1~}_{\geq 0}\underbrace{\verb~00...0~}_{\geq 1}\underbrace{\verb~11...1~}_{\geq 0} \}$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[right = of q1, state, minimum size = 2em] (q2) {};
      \node[accepting, right = of q2, state, minimum size = 2em] (q3) {};
      \draw[->]
      (q1) edge[loop above] node{\verb~1~} (q1)
      (q1) edge[above] node{$\varepsilon$} (q2)
      (q2) edge[loop above] node{\verb~0~} (q2)
      (q2) edge[above] node{\verb~0~} (q3)
      (q3) edge[loop above] node{\verb~1~} (q3)
      ;
    \end{tikzpicture} 
  \end{center}
\end{eg}

\subsection{Alternatives}

\begin{eg}
  Language: $\left \{ w : 2 \mid \left | w \right | \lor 3 \mid \left | w \right | \right \}$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[accepting, above right = of q1, state, minimum size = 2em] (q2) {};
      \node[right = of q2, state, minimum size = 2em] (q3) {};
      \node[accepting, below right = of q1, state, minimum size = 2em] (q4) {};
      \node[above right = of q4, state, minimum size = 2em] (q5) {};
      \node[below right = of q4, state, minimum size = 2em] (q6) {};
      \draw[->]
      (q1) edge[above left] node{$\varepsilon$} (q2)
      (q2) edge[bend right, below] node{\verb~0~,\verb~1~} (q3)
      (q3) edge[bend right, above] node{\verb~0~,\verb~1~} (q2)
      (q1) edge[below left] node{$\varepsilon$} (q4)
      (q4) edge[above left] node{\verb~0~,\verb~1~} (q5)
      (q5) edge[right] node{\verb~0~,\verb~1~} (q6)
      (q6) edge[below left] node{\verb~0~,\verb~1~} (q4)
      ;
    \end{tikzpicture}
  \end{center}
  
  \newpage
  
  Note that the following is not valid due to side effects: 

  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[accepting, initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[right = of q1, state, minimum size = 2em] (q2) {};
      \node[accepting, below = of q1, state, minimum size = 2em] (q3) {};
      \node[below left = of q3, state, minimum size = 2em] (q4) {};
      \node[below right = of q3, state, minimum size = 2em] (q5) {};
      \draw[->]
      (q1) edge[bend right, below] node{\verb~0~,\verb~1~} (q2)
      (q2) edge[bend right, above] node{\verb~0~,\verb~1~} (q1)
      (q1) edge[left] node{$\varepsilon$} (q3)
      (q3) edge[above left] node{\verb~0~,\verb~1~} (q4)
      (q4) edge[below] node{\verb~0~,\verb~1~} (q5)
      (q5) edge[above right] node{\verb~0~,\verb~1~} (q3)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\begin{eg}[Week 1 Discussion]
  $L = \{ w : \text{$w$ contains \verb~1101~} \lor w = \underbrace{\verb~11...1~}_{\geq 0}\underbrace{\verb~00...0~}_{\geq 1}\underbrace{\verb~11...1~}_{\geq 0} \}$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (q1) {};
      \node[above right = of q1, style = {draw, rectangle, minimum width = 4em, minimum height = 2em}, minimum size = 2em] (q2) {NFA from Example~\ref{eg:2.3.4}};
      \node[below right = of q1, style = {draw, rectangle, minimum width = 4em, minimum height = 2em}, minimum size = 2em] (q3) {NFA from Example~\ref{eg:2.3.5}};
      \draw[->]
      (q1) edge[above left] node{$\varepsilon$} (q2.west)
      (q1) edge[below left] node{$\varepsilon$} (q3.west)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\begin{eg}
  Language: $\left \{ w : \text{$w$ contains an even number of \verb~0~s, or exactly two \verb~1~s} \right \}$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (1) {};
      \node[above right = of 1, accepting, state, minimum size = 2em] (2) {};
      \node[right = of 2, state, minimum size = 2em] (3) {};
      \node[below right = of 1,state, minimum size = 2em] (4) {};
      \node[right = of 4, state, minimum size = 2em] (5) {};
      \node[accepting, right = of 5, state, minimum size = 2em] (6) {};
      \draw[->]
      (1) edge[above left] node{$\varepsilon$} (2)
      (1) edge[below left] node{$\varepsilon$} (4)
      (2) edge[bend right, below] node{\verb~0~} (3)
      (2) edge[loop above] node{\verb~1~} (2)
      (3) edge[bend right, above] node{\verb~0~} (2)
      (3) edge[loop above] node{\verb~1~} (3)
      (4) edge[above] node{\verb~1~} (5)
      (4) edge[loop above] node{\verb~0~} (4)
      (5) edge[above] node{\verb~1~} (6)
      (5) edge[loop above] node{\verb~0~} (5)
      (6) edge[loop above] node{\verb~0~} (6)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\begin{eg}
  Language: $\left \{ w : \text{$w$ does not contain both \verb~0~ and \verb~1~} \right \}$
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (1) {};
      \node[accepting, above right = of 1, state, minimum size = 2em] (2) {};
      \node[accepting, below right = of 1, state, minimum size = 2em] (3) {};
      \draw[->]
      (1) edge[above left] node{$\varepsilon$} (2)
      (2) edge[loop right] node{\verb~0~} (2)
      (1) edge[below left] node{$\varepsilon$} (3)
      (3) edge[loop right] node{\verb~1~} (3)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\subsection{Formal definitions}

\begin{defn}
  An NFA is a tuple $(Q, \Sigma, \delta q_0, F)$ where
  \begin{itemize}
    \item $Q =$ set of states, 

    \item $\Sigma =$ alphabet, 
      
    \item $\delta =$ transition function ($\delta \colon Q \times (\Sigma \cup \left \{ \varepsilon \right \}) \to \mathcal P(Q)$), 
      
    \item $q_0 =$ start state ($q_0 \in Q$), and 
      
    \item $F =$ set of accept states ($F \subseteq Q$).
  \end{itemize}
\end{defn}

\begin{eg}
  Formal description for NFA from Example~\ref{eg:2.1.1}: 
  \[
    \left ( \left \{ A, B, C, D \right \}, \left \{ \verb~0~, \verb~1~ \right \}, \delta, A, \left \{ D \right \} \right )
  \]
  where $\delta$ is defined by the table 
  \begin{center}
    \begin{tabular}{c|ccc}
      & \verb~0~ & \verb~1~ & $\varepsilon$ \\ 
      \hline
      $A$ & $\left \{ A \right \}$ & $\left \{ A, B \right \}$ & $\varnothing$ \\ 
      $B$ & $\left \{ C \right \}$ & $\varnothing$ & $\left \{ C \right \}$ \\ 
      $C$ & $\varnothing$ & $\left \{ D \right \}$ & $\varnothing$ \\ 
      $D$ & $\left \{ D \right \}$ & $\left \{ D \right \}$ & $\varnothing$.
    \end{tabular}
  \end{center}
  
  Note that as pictures are not precise, we had to make an assumption on the alphabet of the NFA.
  Also note that although adding transition from $A$ to $A$ on $\varepsilon$ does not change the language, it does not match the drawing and therefore represents a different NFA.
  Make sure to transcribe the given NFA.
\end{eg}

\begin{eg}
  $(\left \{ A, B, C \right \}, \left \{ \verb~0~, \verb~1~ \right \}, \delta, A, \left \{ B \right \})$ where $\delta$ is defined by the table 
  \begin{center}
    \begin{tabular}{c|ccc}
      & \verb~0~ & \verb~1~ & $\varepsilon$ \\ 
      \hline
      $A$ & $\left \{ C \right \}$ & $\left \{ B \right \}$ & $\varnothing$ \\ 
      $B$ & $\left \{ A \right \}$ & $\varnothing$ & $\varnothing$ \\ 
      $C$ & $\left \{ B \right \}$ & $\left \{ B, C \right \}$ & $\left \{ A \right \}$. 
    \end{tabular}
  \end{center}
  
  \begin{center}
    \begin{tikzpicture}[> = stealth, node distance = 3em]
      \node[initial, initial text=, state, minimum size = 2em] (A) {$A$};
      \node[accepting, right = of A, state, minimum size = 2em] (B) {$B$};
      \node[right = of B, state, minimum size = 2em] (C) {$C$};
      \draw[->]
      (A) edge[bend right = 55, below] node{\verb~0~} (C)
      (A) edge[bend right, below] node{\verb~1~} (B)
      (B) edge[bend right, above] node{\verb~0~} (A)
      (C) edge[bend right = 55, above] node{\verb~0~} (A)
      (C) edge[above] node{\verb~1~} (B)
      (C) edge[loop right] node{\verb~1~} (C)
      (C) edge[bend right = 80, above] node{$\varepsilon$} (A)
      ;
    \end{tikzpicture}
  \end{center}
\end{eg}

\newpage

\begin{defn}
  NFA $(Q, \Sigma, \delta, q_0, F)$ {\boldmath \bfseries accepts} a string $w$ iff 
  \begin{align*}
    \exists \, q_1, q_2, \dots, q_m \in Q \, &\exists \, \sigma_0, \sigma_1, \dots, \sigma_{m - 1} \in \Sigma \cup \left \{ \varepsilon \right \}: \\ 
    &q_1 \in \delta(q_0, \delta_0) \land q_2 \in \delta(q_1, \sigma) \land \cdots \\ 
    &\land q_m \in \delta(q_{m - 1}, \sigma_{m - 1}) \land q_m \in F \\ 
    &\land \sigma_0 \sigma_1 \dots \sigma_{m - 1} = w, 
  \end{align*}
  or, in words, an accept state is reachable from $q_0$ via some path on input $w$.
\end{defn}

\begin{defn}
  NFA $N$ {\boldmath \bfseries recognizes} the language $\mathcal L$ iff 
  \[
    \mathcal L = \left \{ w : \text{$N$ accepts $w$} \right \}.
  \]
\end{defn}

\section{Equivalence of DFAs and NFAs}

\subsection{Example}

Does this NFA accept the string \verb~0110~?

\begin{center}
  \begin{tikzpicture}[> = stealth, node distance = 3em]
    \node[accepting, state, minimum size = 2em] (A) {$A$};
    \node[below right = of A, state, minimum size = 2em] (B) {$B$};
    \node[accepting, above right = of A, state, minimum size = 2em] (C) {$C$};
    \draw[->]
    (A) edge[bend right, below] node{$\varepsilon$} (C)
    (C) edge[bend right, above] node{\verb~0~} (A)
    (A) edge[below left] node{\verb~1~} (B)
    (B) edge[right] node{\verb~0~,\verb~1~} (C)
    (B) edge[loop right] node{\verb~0~} (B)
    ;
  \end{tikzpicture}
\end{center}

Recall that the NFA accepts \verb~0110~ iff an accept state is reachable from the start state via some path $\underbrace{\varepsilon \dots \varepsilon}_{\geq 0} \verb~0~ \underbrace{\varepsilon \dots \varepsilon}_{\geq 0} \verb~1~ \underbrace{\varepsilon \dots \varepsilon}_{\geq 0} \verb~1~ \underbrace{\varepsilon \dots \varepsilon}_{\geq 0} \verb~0~ \underbrace{\varepsilon \dots \varepsilon}_{\geq 0}$.

\begin{center}
  \begin{tabular}{cc}
    Path & Possible end states \\ 
    \hline
    $\varepsilon \dots \varepsilon$ & $A, C$ \\ 
    $\varepsilon \dots \varepsilon \verb~0~ \varepsilon \dots \varepsilon$ & $A, C$ \\ 
    $\varepsilon \dots \varepsilon \verb~0~ \varepsilon \dots \varepsilon \verb~1~ \varepsilon \dots \varepsilon$ & $B$ \\ 
    $\varepsilon \dots \varepsilon \verb~0~ \varepsilon \dots \varepsilon \verb~1~ \varepsilon \dots \varepsilon \verb~1~ \varepsilon \dots \varepsilon$ & $C$ \\ 
    $\varepsilon \dots \varepsilon \verb~0~ \varepsilon \dots \varepsilon \verb~1~ \varepsilon \dots \varepsilon \verb~1~ \varepsilon \dots \varepsilon \verb~0~ \varepsilon \dots \varepsilon$ & $A, C$ \\ 
  \end{tabular}
\end{center}

Since $C$ is an accept state, the NFA accepts the string \verb~0110~.

\newpage

Can we convert this to a DFA? Yes.

\begin{oldenumerate}[topsep = 0ex, label = {\textbf{Step \arabic*}}]
  \item Use subsets of the states of the NFA as the states of the DFA.
  Accept states are subsets that contain accept states of the NFA.
  The start state is the subset of all reachable states from the start state of the NFA via $\varepsilon$.
  For subsets containing more than one element, the transition is the union of all transitions for each individual element.
  
  \begin{center}
    \linespread{0.8}
    \begin{tikzpicture}[
      > = stealth, 
      node distance = 4em
    ]
      \node[state, minimum size = 2em] (0) {$\varnothing$};
      \node[right = of 0, accepting, state, minimum size = 2em] (A) {$\left \{ A \right \}$};
      \node[right = of A, state, minimum size = 2em] (B) {$\left \{ B \right \}$};
      \node[accepting, right = of B, state, minimum size = 2em] (AB) {$\left \{ A, B \right \}$};
      \node[below = of 0, state, minimum size = 2em] (C) {$\left \{ C \right \}$};
      \node[initial below, initial text=, accepting, right = of C, state, minimum size = 2em] (AC) {$\left \{ A, C \right \}$};
      \node[right = of AC, state, minimum size = 2em] (BC) {$\left \{ B, C \right \}$};
      \node[accepting, right = of BC, state, minimum size = 2em] (ABC) {$\left \{ A, B, C \right \}$};
      \draw[->]
      (0) edge[loop above] node{$\verb~0~ \varepsilon \dots \varepsilon, \verb~1~ \varepsilon \dots \varepsilon$} (0)
      (A) edge[above] node{$\verb~0~ \varepsilon \dots \varepsilon$} (0)
      (A) edge[above] node{$\verb~1~ \varepsilon \dots \varepsilon$} (B)
      (B) edge node[above, sloped]{$\verb~0~ \varepsilon \dots \varepsilon$} (BC)
      (B) edge node[above, sloped]{$\verb~1~ \varepsilon \dots \varepsilon$} (C)
      (C) edge[below] node{$\verb~0~ \varepsilon \dots \varepsilon$} (AC)
      (C) edge[left] node{$\verb~1~ \varepsilon \dots \varepsilon$} (0)
      (AC) edge[loop right] node[below left = 1.5ex and -1em]{$\verb~0~ \varepsilon \dots \varepsilon$} (AC)
      (AC) edge node[below, sloped]{$\verb~1~ \varepsilon \dots \varepsilon$} (B)
      (BC) edge[bend right, below] node{$\verb~0~ \varepsilon \dots \varepsilon$} (ABC)
      (BC) edge[bend left = 45, below] node{$\verb~1~ \varepsilon \dots \varepsilon$} (C)
      (ABC) edge[loop right] node[below left = 1.7ex and -1em]{$\verb~0~ \varepsilon \dots \varepsilon$} (ABC)
      (ABC) edge[bend right, above] node{$\verb~1~ \varepsilon \dots \varepsilon$} (BC)
      (AB) edge node[above, sloped, align = left]{$\verb~0~ \varepsilon \dots \varepsilon$, \\ $\verb~1~ \varepsilon \dots \varepsilon$} (BC)
      ;
    \end{tikzpicture}
  \end{center}
  
  \item Clean up.

  \begin{center}
    \linespread{0.8}
    \begin{tikzpicture}[
      > = stealth, 
      node distance = 4em
    ]
      \node[state, minimum size = 2em] (0) {};
      \node[right = of 0, accepting, state, minimum size = 2em] (1) {};
      \node[right = of 1, state, minimum size = 2em] (2) {};
      \node[accepting, right = of 2, state, minimum size = 2em] (3) {};
      \node[below = of 0, state, minimum size = 2em] (4) {};
      \node[initial below, initial text=, accepting, right = of 4, state, minimum size = 2em] (5) {};
      \node[right = of 5, state, minimum size = 2em] (6) {};
      \node[accepting, right = of 6, state, minimum size = 2em] (7) {};
      \draw[->]
      (0) edge[loop above] node{\verb~0~,\verb~1~} (0)
      (1) edge[above] node{\verb~0~} (0)
      (1) edge[above] node{\verb~1~} (2)
      (2) edge node[right]{\verb~0~} (6)
      (2) edge node[above, sloped]{\verb~1~} (4)
      (4) edge[below] node{\verb~0~} (5)
      (4) edge[left] node{\verb~1~} (0)
      (5) edge[loop right] node{\verb~0~} (5)
      (5) edge node[below, sloped]{\verb~1~} (2)
      (6) edge[bend right, below] node{\verb~0~} (7)
      (6) edge[bend left = 45, below] node{\verb~1~} (4)
      (7) edge[loop right] node{\verb~0~} (ABC)
      (7) edge[bend right, above] node{\verb~1~} (6)
      (3) edge node[above, sloped, align = left]{\verb~0~,\verb~1~} (6)
      ;
    \end{tikzpicture}
  \end{center}
  
  \item Optionally drop unreachable states.

  \begin{center}
    \linespread{0.8}
    \begin{tikzpicture}[
      > = stealth, 
      node distance = 4em
    ]
      \node[state, minimum size = 2em] (0) {};
      \node[right = 10em of 0, state, minimum size = 2em] (2) {};
      \node[below = of 0, state, minimum size = 2em] (4) {};
      \node[initial below, initial text=, accepting, right = of 4, state, minimum size = 2em] (5) {};
      \node[right = of 5, state, minimum size = 2em] (6) {};
      \node[accepting, right = of 6, state, minimum size = 2em] (7) {};
      \draw[->]
      (0) edge[loop above] node{\verb~0~,\verb~1~} (0)
      (2) edge node[right]{\verb~0~} (6)
      (2) edge node[above, sloped]{\verb~1~} (4)
      (4) edge[below] node{\verb~0~} (5)
      (4) edge[left] node{\verb~1~} (0)
      (5) edge[loop right] node{\verb~0~} (5)
      (5) edge node[below, sloped]{\verb~1~} (2)
      (6) edge[bend right, below] node{\verb~0~} (7)
      (6) edge[bend left = 45, below] node{\verb~1~} (4)
      (7) edge[loop right] node{\verb~0~} (ABC)
      (7) edge[bend right, above] node{\verb~1~} (6)
      ;
    \end{tikzpicture}
  \end{center}
\end{oldenumerate}

\newpage

\subsection{General theorem}

\begin{thm}
  Every NFA $N$ can be converted to a DFA $D$ that recognizes the same language.
\end{thm}

\begin{prf}
  Given NFA $N = (Q, \Sigma, \delta, q_0, F)$ define DFA $D = (\mathcal P(Q), \Sigma, \Delta, S_0, \mathscr F)$ where 
  \begin{itemize}
    \item $S_0 = \{ q \in Q : \text{$q$ is reachable from $q_0$ via a path $\underbrace{\varepsilon \dots \varepsilon}_{\geq 0}$} \}$, 

    \item $\Delta(S, \sigma) = \{ q \in Q : \text{$q$ is reachable from a state in $S$ via a path $\delta \underbrace{\varepsilon \dots \varepsilon}_{\geq 0}$} \}$, and 

    \item $\mathscr F = \left \{ S \subseteq Q : \text{$S$ contains a state in $F$} \right \}$.
  \end{itemize}
  
  Then $N$ accepts a string $w = w_1 w_2 \dots w_n$ $\Leftrightarrow$ a state in $F$ is reachable via a path $\underbrace{\varepsilon \dots \varepsilon}_{\geq 0} w_1 \underbrace{\varepsilon \dots \varepsilon}_{\geq 0} w_2 \dots w_n \underbrace{\varepsilon \dots \varepsilon}_{\geq 0}$ $\Leftrightarrow$ a state in $\mathscr F$ is reachable from $S_0$ via the path $w_1 w_2 \dots w_n$ $\Leftrightarrow$ $D$ accepts $w$.
\end{prf}

\end{document}